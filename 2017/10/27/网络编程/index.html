<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="author" content="马云昊">





<title>网络编程 | MaYunhao&#39;s Blog</title>



    <link rel="icon" href="/favicon.ico">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    



    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script>
    



    
    
        
    


</head>
<body>
    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo"><a href="/">马云昊的技术博客</a></div>
            <div class="menu navbar-right">
                
                    <a class="menu-item" href="/archives">文章</a>
                
                    <a class="menu-item" href="/categories">分类</a>
                
                    <a class="menu-item" href="/tags">标签</a>
                
                    <a class="menu-item" href="/about">关于我</a>
                
                <input id="switch_default" type="checkbox" class="switch_default">
                <label for="switch_default" class="toggleBtn"></label>
            </div>

        </div>
    </nav>

    
    <nav class="navbar-mobile" id="nav-mobile">
        <div class="container">
            <div class="navbar-header">
                <div>
                    <a href="/">马云昊的技术博客</a><a id="mobile-toggle-theme">·&nbsp;Light</a>
                </div>
                <div class="menu-toggle" onclick="mobileBtn()">&#9776; Menu</div>
            </div>
            <div class="menu" id="mobile-menu">
                
                    <a class="menu-item" href="/archives">文章</a>
                
                    <a class="menu-item" href="/categories">分类</a>
                
                    <a class="menu-item" href="/tags">标签</a>
                
                    <a class="menu-item" href="/about">关于我</a>
                
            </div>
        </div>
    </nav>

</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if(toggleMenu.classList.contains("active")){
           toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        }else{
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>
        <div class="main">
            <div class="container">
    
    
        <div class="post-toc">
    <div class="tocbot-list">
    </div>
    <div class="tocbot-list-menu">
        <a class="tocbot-toc-expand" onclick="expand_toc()">Expand all</a>
        <a onclick="go_top()">Back to top</a>
        <a onclick="go_bottom()">Go to bottom</a>
    </div>
</div>

<script>
    document.ready(
        function () {
            tocbot.init({
                tocSelector: '.tocbot-list',
                contentSelector: '.post-content',
                headingSelector: 'h1, h2, h3, h4, h5',
                collapseDepth: 1,
                orderedList: false,
                scrollSmooth: true,
            })
        }
    )

    function expand_toc() {
        var b = document.querySelector(".tocbot-toc-expand");
        tocbot.init({
            tocSelector: '.tocbot-list',
            contentSelector: '.post-content',
            headingSelector: 'h1, h2, h3, h4, h5',
            collapseDepth: 6,
            orderedList: false,
            scrollSmooth: true,
        });
        b.setAttribute("onclick", "collapse_toc()");
        b.innerHTML = "Collapse all"
    }

    function collapse_toc() {
        var b = document.querySelector(".tocbot-toc-expand");
        tocbot.init({
            tocSelector: '.tocbot-list',
            contentSelector: '.post-content',
            headingSelector: 'h1, h2, h3, h4, h5',
            collapseDepth: 1,
            orderedList: false,
            scrollSmooth: true,
        });
        b.setAttribute("onclick", "expand_toc()");
        b.innerHTML = "Expand all"
    }

    function go_top() {
        window.scrollTo(0, 0);
    }

    function go_bottom() {
        window.scrollTo(0, document.body.scrollHeight);
    }

</script>
    

    
    <article class="post-wrap">
        <header class="post-header">
            <h1 class="post-title">网络编程</h1>
            
                <div class="post-meta">
                    
                        Author: <a itemprop="author" rel="author" href="/">马云昊</a>
                    

                    
                        <span class="post-time">
                        Date: <a href="#">十月 27, 2017&nbsp;&nbsp;0:00:00</a>
                        </span>
                    
                    
                        <span class="post-category">
                    Category:
                            
                                <a href="/categories/python/">python</a>
                            
                        </span>
                    
                </div>
            
        </header>

        <div class="post-content">
            <h3 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h3><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><ol>
<li><p>IPV4和IPV6是什么</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">ipv4:网际协议版本4（英语：Internet Protocol version 4，IPv4），又称互联网通信协议第四版，是网际协议开发过程中的第四个修订版本，也是此协议第一个被广泛部署的版本。IPv4是互联网的核心，也是使用最广泛的网际协议版本，其后继版本为IPv6，直到2011年，IANA IPv4位址完全用尽时</span></span><br><span class="line"><span class="string">	2019年11月26日，全球所有43亿个IPv4地址已分配完毕，这意味着没有更多的IPv4地址可以分配给ISP和其他大型网络基础设施提供商。</span></span><br><span class="line"><span class="string">	IPv4在IETF于1981年9月发布的 RFC 791 中被描述，此RFC替换了于1980年1月发布的 RFC 760。</span></span><br><span class="line"><span class="string">	IPv4是一种无连接的协议，操作在使用分组交换的链路层（如以太网）上。此协议会尽最大努力交付数据包，意即它不保证任何数据包均能送达目的地，也不保证所有数据包均按照正确的顺序无重复地到达。这些方面是由上层的传输协议（如传输控制协议）处理的。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">ipv6:IPv6是英文“Internet Protocol Version 6”（互联网协议第6版）的缩写，是互联网工程任务组（IETF）设计的用于替代IPv4的下一代IP协议，其地址数量号称可以为全世界的每一粒沙子编上一个地址  。</span></span><br><span class="line"><span class="string">	由于IPv4最大的问题在于网络地址资源有限，严重制约了互联网的应用和发展。IPv6的使用，不仅能解决网络地址资源数量的问题，而且也解决了多种接入设备连入互联网的障碍   。</span></span><br><span class="line"><span class="string">	互联网数字分配机构（IANA）在2016年已向国际互联网工程任务组（IETF）提出建议，要求新制定的国际互联网标准只支持IPv6，不再兼容IPv4。</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>什么是tcp，udp</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">tcp: 传输控制协议（TCP）是一种网络通信协议，旨在通过Internet发送数据包。TCP是OSI层中的传输层协议，用于通过传输和确保通过支持网络和Internet传递消息来在远程计算机之间创建连接</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">udp:用户数据报协议（UDP）是在网络上的不同计算机上运行的程序使用的Internet协议套件的一部分。UDP用于发送称为数据报的短消息，但总的来说，它是一种不可靠的无连接协议</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>TCP由什么构成?滑动窗口是什么?</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">从协议分层模型方面来讲，TCP/IP由四个层次组成：网du络接口层、网络层、传zhi输层、应用层。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">窗口滑动：窗口字段用来控制对方发送的数据量，告知对方目前自身的缓冲区容量(Receive Buffer)，当该值为0时，代表缓冲区已经额满，需要暂停接收数据</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>HTTP和HTTPS的区别</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">HTTP属于超文本传输协议，用来在Internet上传送超文本，而HTTPS为安全超文本传输协议，在HTTPS基础上拥有更强的安全性，简单来说HTTPS是HTTP的安全版，是使用TLS/SSL加密的HTTP协议</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>SMTP,NTP,FTP,SFTP,SSH</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">SMTP:SMTP(Simple Mail Transfer Protocol)即简单邮件传输协议，常用端口为25，属于TCP/IP协议簇;</span></span><br><span class="line"><span class="string">可以通过SMTP协议在不同主机间进行邮件发送。更大多数TCP/IP应用层协议类似，SMTP协议也存在两个端：发信人、收信人处于客户端，对应邮件系统运营商为服务端</span></span><br><span class="line"><span class="string">	</span></span><br><span class="line"><span class="string">	pop3:是Post Office Protocol 3的简称，即邮局协议的第3个版本,它规定怎样将个人计算机连接到Internet的邮件服务器和下载电子邮件的电子协议。它是因特网电子邮件的第一个离线协议标准,POP3允许用户从服务器上把邮件存储到本地主机（即自己的计算机）上,同时删除保存在邮件服务器上的邮件，而POP3服务器则是遵循POP3协议的接收邮件服务器，用来接收电子邮件的</span></span><br><span class="line"><span class="string">	</span></span><br><span class="line"><span class="string">	IMAP:称是Internet Mail Access Protocol，即交互式邮件存取协议，它是跟POP3类似邮件访问标准协议之一。不同的是，开启了IMAP后，您在电子邮件客户端收取的邮件仍然保留在服务器上，同时在客户端上的操作都会反馈到服务器上，如：删除邮件，标记已读等，服务器上的邮件也会做相应的动作。所以无论从浏览器登录邮箱或者客户端软件登录邮箱，看到的邮件以及状态都是一致的。</span></span><br><span class="line"><span class="string">	</span></span><br><span class="line"><span class="string">	pop3和IMAP的区别：POP3协议允许电子邮件客户端下载服务器上的邮件，但是在客户端的操作（如移动邮件、标记已读等），不会反馈到服务器上，比如通过客户端收取了邮箱中的3封邮件并移动到其他文件夹，邮箱服务器上的这些邮件是没有同时被移动的 。</span></span><br><span class="line"><span class="string">			而IMAP提供webmail 与电子邮件客户端之间的双向通信，客户端的操作都会反馈到服务器上，对邮件进行的操作，服务器上的邮件也会做相应的动作</span></span><br><span class="line"><span class="string">			</span></span><br><span class="line"><span class="string">NTP:NTP服务器【Network Time Protocol（NTP）】是用来使计算机时间同步化的一种协议，它可以使计算机对其服务器或时钟源（如石英钟，GPS等等)做同步化，它可以提供高精准度的时间校正（LAN上与标准间差小于1毫秒，WAN上几十毫秒），且可介由加密确认的方式来防止恶毒的协议攻击。时间按NTP服务器的等级传播。按照离外部UTC源的远近把所有服务器归入不同的Stratum（层）中。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">FTP:文件传输协议（File Transfer Protocol，FTP）是用于在网络上进行文件传输的一套标准协议，它工作在 OSI 模型的第七层， TCP 模型的第四层， 即应用层， 使用 TCP 传输而不是 UDP， 客户在和服务器建立连接前要经过一个“三次握手”的过程， 保证客户与服务器之间的连接是可靠的， 而且是面向连接， 为数据传输提供可靠保证</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">SFTP:sftp是Secure File Transfer Protocol的缩写，安全文件传送协议。可以为传输文件提供一种安全的网络的加密方法。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">ssh:SSH 为 Secure Shell 的缩写，由 IETF 的网络小组（Network Working Group）所制定；SSH 为建立在应用层基础上的安全协议。SSH 是较可靠，专为远程登录会话和其他网络服务提供安全性的协议。利用 SSH 协议可以有效防止远程管理过程中的信息泄露问题。</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>什么是C/S架构?什么又是B/S架构</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">cs: 常用的客户端现在主要为PC端应用软件或是浏览器，也就是人们常说的 C/S(Client/Server) 客户 端/服务端架构、 B/S(Browser/Server) 浏览器/服务端架构。但是不管是什么架构，都需要有服务 器和客户端进行支持。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">bs:</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>详细描述三次握手</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">第一次</span></span><br><span class="line"><span class="string">第一次握手：建立连接时，客户端发送syn包（seq=j）到服务器，并进入SYN_SENT状态，等待服务器确认；SYN：同步序列编号（Synchronize Sequence Numbers）。 [3] </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">第二次</span></span><br><span class="line"><span class="string">第二次握手：服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（seq=k），即SYN+ACK包，此时服务器进入SYN_RECV状态。 [3] </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">第三次</span></span><br><span class="line"><span class="string">第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1），此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手。 [3]</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>TCP常见报文标志有哪些</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">	U: URG ，紧急比特(Urgent); 当URG为1时，表明该字段有效，标示该TCP数据报文优先级为高优先级，会表示刚数据包为 紧急封包，会被加急传输。</span></span><br><span class="line"><span class="string">	A: ACK ，确认比特(Acknowledge) 当该值为1时确认字段才有效，代表这个封包为确认封包;当该值为0时，确认号无效</span></span><br><span class="line"><span class="string">	P: PSH ，推送比特(Push function) 如果该值为1时，代表要求对方立即传输缓冲区内的其他对应封包，不需要等待缓冲区满了之 后才传输</span></span><br><span class="line"><span class="string">	R: RST ，复位比特(Reset) 当该值为1时，表示TCP连接中出现严重差错，必须释放连接，需要重新连接运输连接</span></span><br><span class="line"><span class="string">	S: SYN ，同步比特(Synchronous) 当该值为1时，表示这是一个连接请求或连接接收报文。通常带有SYN标志的封包表示要主动 连接到对方的意思</span></span><br><span class="line"><span class="string">	F: FIN ，终止比特(Final) 当该值为1时，表明TCP数据已经发送结束，并要求释放传输连接</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="套接字编程"><a href="#套接字编程" class="headerlink" title="套接字编程"></a>套接字编程</h3><ol>
<li><p>什么是套接字</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">	一台主机想要和其他主机进行网络通信，那么IP和端口将是必不可少的两个属性。 TCP、UDP作为我们通信时使用的手段，还需要我们提前维护对应的IP及端口(PORT)属性，那么一个具备IP及PORT属性的对象在程序中，被称为套接字</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>Linux下套接字本质是啥</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>手写TCP套接字模型服务端与客户端</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">tcp服务端</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="comment"># 1创建套接字</span></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line">tcp_socket_host = socket.socket(socket.AF_INET,socket.SOCK_STREAM)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 服务器端口回收操作（释放端口）</span></span><br><span class="line">tcp_socket_host.setsockopt(socket.SOL_SOCKET,socket.SO_REUSEADDR,<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2绑定端口</span></span><br><span class="line">tcp_socket_host.bind((<span class="string">''</span>,<span class="number">8080</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3监听  变为被动套接字</span></span><br><span class="line">tcp_socket_host.listen(<span class="number">128</span>)    <span class="comment">#128可以监听的最大数量，最大链接数</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 4等待客户端连接</span></span><br><span class="line">socket_fuwu,addr_client=tcp_socket_host.accept()  <span class="comment">#accept(new_socket,addr)</span></span><br><span class="line">print(socket_fuwu)</span><br><span class="line">print(addr_client)</span><br><span class="line"><span class="comment"># 5读写</span></span><br><span class="line"></span><br><span class="line">recv_data = socket_fuwu.recv(<span class="number">1024</span>)</span><br><span class="line">print(recv_data.decode(<span class="string">'utf-8'</span>))</span><br><span class="line"></span><br><span class="line">seng_data = <span class="string">'你是好人'</span></span><br><span class="line">socket_fuwu.send(seng_data.encode(<span class="string">'utf-8'</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">#6服务套接字关闭</span></span><br><span class="line">socket_fuwu.close()    <span class="comment">#服务器一般不关闭</span></span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">tcp客户端</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1创建套接字</span></span><br><span class="line">tcp_socket = socket(AF_INET,SOCK_STREAM)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2绑定端口</span></span><br><span class="line">ip = input(<span class="string">'请输入要连接服务器ip：'</span>)</span><br><span class="line">port = int(input(<span class="string">'请输入要连接服务器端口：'</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3连接服务器</span></span><br><span class="line">tcp_socket.connect((ip,port))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4发送接收数据</span></span><br><span class="line">send_data = input(<span class="string">'请输入要传送数据：'</span>)</span><br><span class="line">send_data = send_data.encode(<span class="string">'utf-8'</span>)</span><br><span class="line">tcp_socket.send(send_data)</span><br><span class="line"></span><br><span class="line">recv_data = tcp_socket.recv(<span class="number">1024</span>)</span><br><span class="line">recv_data = recv_data.decode(<span class="string">'utf-8'</span>)</span><br><span class="line">print(recv_data)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 5关闭套接字</span></span><br><span class="line">tcp_socket.close()</span><br></pre></td></tr></table></figure>
</li>
<li><p>手写udp套接字模型服务端与客户端</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">udp服务端</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> ctime</span><br><span class="line"></span><br><span class="line">HOST = <span class="string">''</span></span><br><span class="line">PORT = <span class="number">8888</span></span><br><span class="line">BUFSIZ = <span class="number">1024</span></span><br><span class="line">ADDR = (HOST, PORT)</span><br><span class="line"></span><br><span class="line">udpSerSock = socket(AF_INET, SOCK_DGRAM)</span><br><span class="line">udpSerSock.bind(ADDR)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    print(<span class="string">'waiting for message...'</span>)</span><br><span class="line">    data, addr = udpSerSock.recvfrom(BUFSIZ)</span><br><span class="line"></span><br><span class="line">    content = <span class="string">'[%s] %s'</span> % (bytes(ctime(), <span class="string">"utf-8"</span>), data)</span><br><span class="line">    udpSerSock.sendto(content.encode(<span class="string">"utf-8"</span>), addr)</span><br><span class="line">    print(<span class="string">'...received from and returned to:'</span>, addr)</span><br><span class="line"></span><br><span class="line">udpSerSock.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">udp客户端</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">HOST = <span class="string">'localhost'</span></span><br><span class="line">PORT = <span class="number">8888</span></span><br><span class="line">BUFSIZ = <span class="number">1024</span></span><br><span class="line">ADDR = (HOST, PORT)</span><br><span class="line"></span><br><span class="line">udpCliSock = socket(AF_INET, SOCK_DGRAM)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    data = input(<span class="string">'&gt; '</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> data:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    udpCliSock.sendto(data.encode(<span class="string">"utf-8"</span>), ADDR)</span><br><span class="line">    data, ADDR = udpCliSock.recvfrom(BUFSIZ)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> data:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    print(data)</span><br><span class="line"></span><br><span class="line">udpCliSock.close()</span><br></pre></td></tr></table></figure>
</li>
<li><p>什么是套接字非阻塞</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">在非阻塞模式下，我们不会去等到一个客户端连接就可以继续代码里面下面的语句</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>listen一般用来干什么</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">服务端套接字开启TCP监听，其中的参数值代表可以有的最大连接等待数</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>面向连接和无连接是什么</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">	在面向连接的方法中，网络负责顺序发送报文分组并且以一种可靠的方法检测丢失和冲突。这种方法被“可靠的”传输服务使用。</span></span><br><span class="line"><span class="string">	</span></span><br><span class="line"><span class="string">	在无连接的方法中，网络只需要将报文分组发送到接收点，检错与流控由发送方和接收方处理。这种方法被称作“最佳工作(best-effort)”或“无应答(unacknowledged)”的传输协议所使用。</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>全双工和半双工是什么</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">全双工： 全双工（Full Duplex）是通讯传输的一个术语。通信允许数据在两个方向上同时传输，它在能力上相当于两个单工通信方式的结合。全双工指可以同时（瞬时）进行信号的双向传输（A→B且B→A）。指A→B的同时B→A，是瞬时同步的。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">半双工:半双工(Half Duplex)数据传输指数据可以在一个信号载体的两个方向上传输，但是不能同时传输。例如，在一个局域网上使用具有半双工传输的技术，一个工作站可以在线上发送数据，然后立即在线上接收数据，这些数据来自数据刚刚传输的方向。像全双工传输一样，半双工包含一个双向线路（线路可以在两个方向上传递数据）</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="网络模型"><a href="#网络模型" class="headerlink" title="网络模型"></a>网络模型</h3><ol>
<li><p>什么是Select模型</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">利用select函数，判断套接字上是否存在数据，或者能否向一个套接字写入数据。目的是防止应用程序在套接字处于锁定模式时，调用recv（或send）从没有数据的套接字上接收数据，被迫进入阻塞状态。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">select的底层是一个fd_set的数据结构，本质上是一个long类型的数组，数组中每一个元素都对应于一个文件描述符，通过轮询所有的文件描述符来检查是否有事件发生</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>什么是Epoll模型</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">大量应用程序请求时能够获得较好的性能（ 此时被监视的文件描述符数目非常大，与旧的 select 和 poll 系统调用完成操作所需 O(n) 不同， epoll能在O(1)时间内完成操作，所以性能相当高），epoll 与 FreeBSD的kqueue类似，都向用户空间提供了自己的文件描述符来进行操作。</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>什么是Poll模型</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">它和select在本质上没有多大差别，但是poll没有最大文件描述符数量的限制</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">poll和select同样存在一个缺点就是，包含大量文件描述符的数组被整体复制于用户态和内核的地址空间之间，而不论这些文件描述符是否就绪，它的开销随着文件描述符数量的增加而线性增大。</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>Apache和nginx的底层是啥</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">Apache:APACHE就是一个网络服务器，bai这个服务器侦du听一个TCP端口zhi，一般是80，对端口收到的命令进行解释，然后提交一些结果。APACHE解释的最主要的命令就是GET和POST，一般对应客户端在浏览器输入地址、浏览器里面点击链接和提交一个表单。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">nginx:</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>单路io复用是啥</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">最简单的一个线程管理一个客户端的socket IO，那么需要1万的线程，假设每个线程占内存3MB，需要300G内存，单台服务器没那么大的内存，并且操作系统最大线程数有限制，unix下一个进程好像是最多只能开 4096 个线程。</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>实现一个聊天室</p>
</li>
</ol>
<h3 id="UWSGI-WSGI"><a href="#UWSGI-WSGI" class="headerlink" title="UWSGI/WSGI"></a>UWSGI/WSGI</h3><ol>
<li><p>什么是uWSGI</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">	uWSGI是一个Web服务器，它实现了WSGI协议、uwsgi、http等协议。</span></span><br><span class="line"><span class="string">	Nginx中HttpUwsgiModule的作用是与uWSGI服务器进行交换。WSGI是一种Web服务器网关接口。它是一个Web服务器（如nginx，uWSGI等服务器）与web应用（如用Flask框架写的程序）通信的一种规范。</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>什么是WSGI</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">	web服务器网关接口，是一套协议。用于接收用户请求将请求进行初次封装，然后将请求交给web框架</span></span><br><span class="line"><span class="string">	</span></span><br><span class="line"><span class="string">	Web服务器网关接口（Python Web Server Gateway Interface，缩写为WSGI）是为Python语言定义的Web服务器和Web应用程序或框架之间的一种简单而通用的接口。自从WSGI被开发出来以后，许多其它语言中也出现了类似接口。</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>什么是uwsgi</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">	与WSGI一样是一种通信协议，它是uWSGI服务器的独占协议，用于定义传输信息的类型</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>断点续传原理</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">把服务器上的文件分n“等份”，再在准备下载地址按等分一一填充到文件中。</span></span><br><span class="line"><span class="string">当 下载 “等份数据” 时如果未能正常结束，从头下载次等份数据。正常结束后线程下载下一等分。</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>分片上传原理</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">分片上传功能支持将一个文件切割为一系列特定大小的小数据片，分别将这些小数据片分别上传到服务端，全部上传完后再在服务端将这些小数据片合并成为一个资源</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">1.将待上传的文件按预定义的4MB块大小切分为若干个块。如果这个文件小于4MB，当然也就只有一个块；</span></span><br><span class="line"><span class="string">2.将每个块再按预定义的片大小切分为若干个片，先在服务端创建一个相应块（通过调用mkblk，并带上第一个片的内容），然后再循环将所有剩下的片全部上传（通过调用bput,从而完成一个块的上传）；</span></span><br><span class="line"><span class="string">3.在所有块上传完成后，通过调用mkfile将这些上传完成的块信息再严格的按顺序组装出一个逻辑资源的元信息，从而完成整个资源的分片上传过程。</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>

</li>
</ol>

        </div>

        
            <section class="post-copyright">
                
                    <p class="copyright-item">
                        <span>Author:</span>
                        <span>马云昊</span>
                    </p>
                
                
                
                
                     <p class="copyright-item">
                         <span>Slogan:</span>
                         <span>愚者不努力 懒人盼巅峰</span>
                     </p>
                

            </section>
        
        <section class="post-tags">
            <div>
                <span>Tag(s):</span>
                <span class="tag">
                    
                    
                        <a href="/tags/python/"># python</a>
                    
                        
                </span>
            </div>
            <div>
                <a href="javascript:window.history.back();" target="_blank" rel="noopener">back</a>
                <span>· </span>
                <a href="/">home</a>
            </div>
        </section>
        <section class="post-nav">
            
                <a class="prev" rel="prev" href="/2017/10/28/%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/">文件操作</a>
            
            
            <a class="next" rel="next" href="/2017/10/26/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%80%BB%E7%BB%93/">面向对象总结</a>
            
        </section>


    </article>
</div>

        </div>
        <footer id="footer" class="footer">
    <div class="copyright">
        <span>© 马云昊 | Powered by <a href="https://hexo.io" target="_blank">Hexo</a> & <a href="https://github.com/Siricee/hexo-theme-Chic" target="_blank">Chic</a></span>
    </div>
</footer>

    </div>
</body>
</html>
